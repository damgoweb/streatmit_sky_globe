# -*- coding: utf-8 -*-
"""
API client for external weather services.
Handles communication with OpenWeatherMap API with proper error handling and rate limiting.
"""

import requests
import time
import streamlit as st
from typing import Dict, Optional, Any
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import logging

from src.utils.config import config


class APIError(Exception):
    """Custom exception for API-related errors."""
    pass


class RateLimitError(APIError):
    """Exception raised when API rate limit is exceeded."""
    pass


class APIClient:
    """
    Client for handling external API communications.
    Manages rate limiting, retries, and error handling.
    """
    
    def __init__(self):
        """Initialize API client with configuration."""
        self.api_key = self._get_api_key()
        self.base_url = config.OPENWEATHERMAP_BASE_URL
        self.geocoding_url = config.OPENWEATHERMAP_GEOCODING_URL
        
        # Rate limiting
        self.max_requests_per_hour = config.max_requests_per_hour
        self.request_count = 0
        self.last_reset = time.time()
        
        # Setup session with retry strategy
        self.session = self._setup_session()
        
        # Logging
        self.logger = logging.getLogger(__name__)
    
    def _get_api_key(self) -> str:
        """Get API key from configuration."""
        try:
            return config.get_openweathermap_api_key()
        except KeyError:
            st.error("= OpenWeatherMap API­üL-šUŒfD~[“")
            st.info("`.streamlit/secrets.toml`Õ¡¤ëkAPI­ü’ý WfO`UD")
            st.stop()
    
    def _setup_session(self) -> requests.Session:
        """Setup requests session with retry strategy."""
        session = requests.Session()
        
        # Retry strategy
        retry_strategy = Retry(
            total=3,
            backoff_factor=1,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["GET"]
        )
        
        adapter = HTTPAdapter(max_retries=retry_strategy)
        session.mount("http://", adapter)
        session.mount("https://", adapter)
        
        # Default headers
        session.headers.update({
            'User-Agent': 'Sky-Globe/1.0',
            'Accept': 'application/json'
        })
        
        return session
    
    def _check_rate_limit(self) -> bool:
        """
        Check if we're within API rate limits.
        
        Returns:
            bool: True if request is allowed, False otherwise
        """
        current_time = time.time()
        
        # Reset counter every hour
        if current_time - self.last_reset > 3600:
            self.request_count = 0
            self.last_reset = current_time
        
        # Check if we've exceeded the limit
        if self.request_count >= self.max_requests_per_hour:
            self.logger.warning("API rate limit exceeded")
            return False
        
        self.request_count += 1
        return True
    
    def _make_request(self, url: str, params: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Make HTTP request with error handling.
        
        Args:
            url: Request URL
            params: Request parameters
            
        Returns:
            Response data or None if failed
            
        Raises:
            RateLimitError: If rate limit is exceeded
            APIError: For other API errors
        """
        # Check rate limit
        if not self._check_rate_limit():
            raise RateLimitError("API rate limit exceeded. Please wait before making more requests.")
        
        # Add API key to parameters
        params['appid'] = self.api_key
        
        try:
            response = self.session.get(url, params=params, timeout=10)
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            self.logger.error("API request timeout")
            raise APIError("Request timeout - please try again later")
            
        except requests.exceptions.ConnectionError:
            self.logger.error("API connection error")
            raise APIError("Network connection error - please check your internet connection")
            
        except requests.exceptions.HTTPError as e:
            self.logger.error(f"HTTP error: {e.response.status_code}")
            
            if e.response.status_code == 401:
                raise APIError("Invalid API key - please check your configuration")
            elif e.response.status_code == 404:
                raise APIError("Location not found")
            elif e.response.status_code == 429:
                raise RateLimitError("API rate limit exceeded")
            else:
                raise APIError(f"API error: {e.response.status_code}")
                
        except Exception as e:
            self.logger.error(f"Unexpected error: {str(e)}")
            raise APIError(f"Unexpected error: {str(e)}")
    
    def get_current_weather(self, city_name: str, country_code: Optional[str] = None) -> Optional[Dict[str, Any]]:
        """
        Get current weather data for a city.
        
        Args:
            city_name: Name of the city
            country_code: Optional 2-letter country code
            
        Returns:
            Weather data dictionary or None if failed
        """
        query = city_name
        if country_code:
            query = f"{city_name},{country_code}"
        
        params = {
            'q': query,
            'units': 'metric',
            'lang': 'ja'
        }
        
        try:
            url = f"{self.base_url}/weather"
            return self._make_request(url, params)
        except (APIError, RateLimitError) as e:
            st.error(f"L )Çü¿nÖ—k1WW~W_: {str(e)}")
            return None
    
    def get_weather_by_coordinates(self, latitude: float, longitude: float) -> Optional[Dict[str, Any]]:
        """
        Get current weather data by coordinates.
        
        Args:
            latitude: Latitude coordinate
            longitude: Longitude coordinate
            
        Returns:
            Weather data dictionary or None if failed
        """
        params = {
            'lat': latitude,
            'lon': longitude,
            'units': 'metric',
            'lang': 'ja'
        }
        
        try:
            url = f"{self.base_url}/weather"
            return self._make_request(url, params)
        except (APIError, RateLimitError) as e:
            st.error(f"L )Çü¿nÖ—k1WW~W_: {str(e)}")
            return None
    
    def geocode_city(self, city_name: str, limit: int = 5) -> Optional[list[Dict[str, Any]]]:
        """
        Get coordinates for a city using geocoding API.
        
        Args:
            city_name: Name of the city to geocode
            limit: Maximum number of results
            
        Returns:
            List of location data or None if failed
        """
        params = {
            'q': city_name,
            'limit': limit
        }
        
        try:
            url = f"{self.geocoding_url}/direct"
            return self._make_request(url, params)
        except (APIError, RateLimitError) as e:
            st.error(f"L ý"k1WW~W_: {str(e)}")
            return None
    
    def reverse_geocode(self, latitude: float, longitude: float, limit: int = 1) -> Optional[list[Dict[str, Any]]]:
        """
        Get location information from coordinates.
        
        Args:
            latitude: Latitude coordinate
            longitude: Longitude coordinate
            limit: Maximum number of results
            
        Returns:
            List of location data or None if failed
        """
        params = {
            'lat': latitude,
            'lon': longitude,
            'limit': limit
        }
        
        try:
            url = f"{self.geocoding_url}/reverse"
            return self._make_request(url, params)
        except (APIError, RateLimitError) as e:
            st.error(f"L ¸ª³üÇ£ó°k1WW~W_: {str(e)}")
            return None
    
    def get_5day_forecast(self, city_name: str, country_code: Optional[str] = None) -> Optional[Dict[str, Any]]:
        """
        Get 5-day weather forecast for a city.
        
        Args:
            city_name: Name of the city
            country_code: Optional 2-letter country code
            
        Returns:
            Forecast data dictionary or None if failed
        """
        query = city_name
        if country_code:
            query = f"{city_name},{country_code}"
        
        params = {
            'q': query,
            'units': 'metric',
            'lang': 'ja'
        }
        
        try:
            url = f"{self.base_url}/forecast"
            return self._make_request(url, params)
        except (APIError, RateLimitError) as e:
            st.error(f"L )ˆ1nÖ—k1WW~W_: {str(e)}")
            return None
    
    def test_api_connection(self) -> bool:
        """
        Test API connection and key validity.
        
        Returns:
            bool: True if connection successful
        """
        try:
            # Test with Tokyo as it should always work
            response = self.get_current_weather("Tokyo", "JP")
            return response is not None
        except Exception as e:
            self.logger.error(f"API connection test failed: {str(e)}")
            return False
    
    def get_request_stats(self) -> Dict[str, Any]:
        """
        Get current request statistics.
        
        Returns:
            Dictionary with request statistics
        """
        time_since_reset = time.time() - self.last_reset
        time_until_reset = 3600 - time_since_reset
        
        return {
            'requests_made': self.request_count,
            'requests_remaining': self.max_requests_per_hour - self.request_count,
            'time_until_reset': max(0, time_until_reset),
            'reset_time': self.last_reset + 3600
        }
    
    def reset_rate_limit(self) -> None:
        """Reset rate limit counter (for testing purposes)."""
        self.request_count = 0
        self.last_reset = time.time()
    
    def close(self) -> None:
        """Close the session."""
        if hasattr(self, 'session'):
            self.session.close()